<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/core/plugin-manager.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lib/core/plugin-manager.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
 * Copyright (c) 2014, Intel Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU Lesser General Public License,
 * version 2.1, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
 * more details.
 *
 * Created by adua.
 */

/** @module plugin-manager */

var path = require('path');
var fs = require('fs');

var config = require('./config-manager.js').config;

/**
 * Check if plugin file contains all the member variables defined in the interface. It is the plugin
 * that specifies which interface it wants to adhere to.
 * @param pluginPrototype {object} The '.prototype' member of the plugin object ({@tutorial plugin})
 * @param pluginFile {string} Name of plugin file ({@tutorial plugin})
 * @param interfaceSpec {object} The interface specification object the plugin claims to adhere to
 * ({@tutorial plugin-interface})
 */
function validateProperties(pluginPrototype, pluginFile, interfaceSpec) {
  if(!interfaceSpec.properties) {
    return;
  }

  // check if all required properties exist
  for (var i in interfaceSpec.properties) {
    if (!pluginPrototype[interfaceSpec.properties[i]]) {
      throw new Error("Plugin '" + pluginFile + "' does not define required property '" + interfaceSpec.properties[i] + "'.");
    }
  }
}

/**
 * Check if plugin file contains all the methods defined in the interface. It is the plugin
 * that specifies which interface it wants to adhere to.
 * @param pluginPrototype {object} The '.prototype' member of the plugin object ({@tutorial plugin})
 * @param pluginFile {string} Name of plugin file ({@tutorial plugin})
 * @param interfaceSpec {object} The interface specification object the plugin claims to adhere to
 * ({@tutorial plugin-interface})
 */
function validateFunctions(pluginPrototype, pluginFile, interfaceSpec) {
	if(!interfaceSpec.functions) {
		return;
	}
	
	// check if all required function names exist
	for (var j in interfaceSpec.functions) {
		if (!pluginPrototype[interfaceSpec.functions[j]]) {
			throw new Error("Plugin file '" + pluginFile + "' does not define required function '" + interfaceSpec.functions[j] + "'.");
		}
	}
	
	// check that type is indeed a function
	for (var i in interfaceSpec.functions) {
		if ((typeof pluginPrototype[interfaceSpec.functions[i]]) !== "function") {
			throw new Error("Plugin file '" + pluginFile + "' does not define '" + interfaceSpec.functions[i] + "' as a function.");
		}
	}
}

/**
 * Get the interface file the plugin requests to adhere to.
 * @param pluginPrototype {object} The '.prototype' member of the plugin object ({@tutorial plugin})
 * @param pluginName {string} plugin name ({@tutorial plugin})
 * @returns {string} Absolute path of interface file ({@tutorial plugin-interface})
 */
function getPluginInterfaceFilePath(pluginPrototype, pluginName) {
  var foundPath = "";
  var found = config.pluginInterfaceDirPaths.some(function (pluginInterfaceDirPath) {
    var currPath = path.join(pluginInterfaceDirPath, pluginPrototype.interface + ".json");
    if (fs.existsSync(currPath)) {
      foundPath = currPath;
      return true;
    }
  });

  if (!found) {
    throw new Error("Could not find plugin interface file '" + pluginPrototype.interface + ".json" +
      "' required by plugin '" + pluginName + "' in any of the configured plugin interface directories.");
  }

  return foundPath;
}

/**
 * Find the plugin directory
 * @param pluginName {string} plugin name ({@tutorial plugin})
 * @returns {string} Absolute path of plugin directory ({@tutorial plugin})
 */
function getPluginDirectoryPath(pluginName) {
  "use strict";
  var foundPath = "";
  var found = config.pluginDirPaths.some(function (pluginDirPath) {
    var currPath = path.join(pluginDirPath, pluginName);
    if (fs.existsSync(currPath)) {
      foundPath = currPath;
      return true;
    }
  });

  if (!found) {
    throw new Error("Could not find plugin '" + pluginName + "' in any of the configured plugin directories.");
  }

  return foundPath;
}

/**
 * Loaded plugin objects ({@tutorial plugin}).
 * e.g. loadedPlugins[name of plugin]['client' or 'server'] returns server or client-side plugin object
 * @type {object.&lt;object, object>}
 */
exports.loadedPlugins = {};

/** This library's config file object */
exports.config = require('./config-manager.js').config;

/**
 * Load a plugin. A specific plugin is loaded only when clients are trying to connect to a service that
 * uses the communication plugin, or when a service using the communication plugin starts ({@tutorial plugin}).
 * @param pluginName {string} name of plugin
 */
exports.loadPlugin = function(pluginName)
{
  var emptyPlugin = true;
  var pluginDirectoryPath = getPluginDirectoryPath(pluginName);
  var suffixKeys = Object.keys(config.communicationPlugins.fileSuffixes);

	for (var i = 0; i &lt; suffixKeys.length; i++) {
    var suffix = config.communicationPlugins.fileSuffixes[suffixKeys[i]];
    var pluginFileName = pluginName + '-' + suffix + '.js';
    var pluginFilePath = path.join(pluginDirectoryPath, pluginFileName);

    if (!fs.existsSync(pluginFilePath)) {
      continue;
    }

    emptyPlugin = false;

		var plugin = require(pluginFilePath);
		var pluginPrototype = null;

		if (typeof plugin === "function" &amp;&amp; plugin.prototype)
		{ // if pluginPrototype is defined as a class with module.exports = &lt;constructor name>
				pluginPrototype = plugin.prototype;
		} else {
      throw ("Plugin " + pluginName + " must be defined like a class using the prototype object. " +
         "Its functionality should be exported using the module.exports = Constructor() convention.");
    }

    // todo: the path at which the super interface is available needs to be a constant and not dependent on anything else.
		var superInterfaceSpec = JSON.parse(fs.readFileSync(config.superInterfaceFilePath));

		// check if interface contains properties and functions that all interfaces are required to have
		// need to do this here since pluginPrototype.interface is needed below
		validateProperties(pluginPrototype, pluginFileName, superInterfaceSpec);
		validateFunctions(pluginPrototype, pluginFileName, superInterfaceSpec);

		var pluginInterfaceFilePath = getPluginInterfaceFilePath(pluginPrototype, pluginName);
		var pluginInterfaceSpec = JSON.parse(fs.readFileSync(pluginInterfaceFilePath));

    validateProperties(pluginPrototype, pluginFileName, pluginInterfaceSpec);
    validateFunctions(pluginPrototype, pluginFileName, pluginInterfaceSpec);

    if (!exports.loadedPlugins[pluginName]) {
      exports.loadedPlugins[pluginName] = {};
    }

    if (exports.loadedPlugins[pluginName][suffix]) {
      console.log("INFO: Plugin file '" + pluginName + '-' + suffix + ".js' already loaded. Skipping...");
      continue;
    }

    exports.loadedPlugins[pluginName][suffix] = plugin;
	}

  if (emptyPlugin) {
    console.log("WARN: No plugin files were found. Empty plugin directory?");
  }
};

/**
 * Plugins have a client-side component and a server-side component.
 * Load the client-side component. ({@tutorial plugin})
 * @param name {string} plugin name
 * @returns {object} client-side plugin object ({@tutorial plugin})
 */
exports.getClientPlugin = function (name) {
  if (!exports.loadedPlugins[name]) {
    this.loadPlugin(name);
  }

  return exports.loadedPlugins[name][config.communicationPlugins.fileSuffixes.clientFileSuffix];
};

/**
 * Plugins have a client-side component and a server-side component.
 * Load the client-side component. ({@tutorial plugin})
 * @param name {string} plugin name
 * @returns {object} server-side plugin object ({@tutorial plugin})
 */
exports.getServicePlugin = function (name) {
  if (!exports.loadedPlugins[name]) {
    this.loadPlugin(name);
  }

  return exports.loadedPlugins[name][config.communicationPlugins.fileSuffixes.serverFileSuffix];
};

</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-config-manager.html">config-manager</a></li><li><a href="module-EdisonMDNS.html">EdisonMDNS</a></li><li><a href="module-plugin-manager.html">plugin-manager</a></li><li><a href="module-ServiceQuery.html">ServiceQuery</a></li><li><a href="module-ServiceRecord.html">ServiceRecord</a></li></ul><h3>Classes</h3><ul><li><a href="Client.html">Client</a></li><li><a href="EdisonMQTTClient.html">EdisonMQTTClient</a></li><li><a href="EdisonMQTTService.html">EdisonMQTTService</a></li><li><a href="module-EdisonMDNS-EdisonMDNS.html">EdisonMDNS</a></li><li><a href="module-ServiceQuery-ServiceQuery.html">ServiceQuery</a></li><li><a href="module-ServiceRecord-ServiceRecord.html">ServiceRecord</a></li><li><a href="Service.html">Service</a></li><li><a href="ServiceSpecValidator.html">ServiceSpecValidator</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-service-query.html">Service Query</a></li><li><a href="tutorial-service-record.html">Service Record</a></li><li><a href="tutorial-service-spec.html">Service Specification</a></li></ul><h3>Global</h3><ul><li><a href="global.html#edison">edison</a></li><li><a href="global.html#edisonLib">edisonLib</a></li><li><a href="global.html#expect">expect</a></li><li><a href="global.html#mqtt">mqtt</a></li><li><a href="global.html#path">path</a></li><li><a href="global.html#run">run</a></li><li><a href="global.html#util">util</a></li><li><a href="global.html#zeromq">zeromq</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a> on Wed May 21 2014 15:28:38 GMT-0700 (PDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
